DEVOPS ELECTIVE
SDLC
   -requirement analysis
   -planning
   -design
   -development
   -testing
   -deployment
   -maintenance and support
methodolodies/practice
   -waterfalls model(environment(development ,testing,production))
       -Phases are completed one at a time, in order
       -No overlap between phases
       - cant able to rollback(don't accept new feature after development)
   -Agile(environment(development,production))
       -new features are acceptable)
       - development and testing team integrated
       -may have a conversation with stakeholder but not in waterfalls
   -devops(environment(development,operation)
user acceptance testing(pre production)



CI/CD
code -> build -> test -> deploy
(code,build,test)=> continuous integration
(code,build,test,deploy)=>CD(CD can be achieved only with CI)
pipeline(sequence of **)


GIT
Local Version Control System (LVCS)
it is a version control system that keep tracking of changes in the code


commands
ls
pwd
nano index.html
git status

git log
git log --oneline(to revoke back to)
git revert HEAD (to revert back to first commit)
git reset (it will delete the commit)
git reset Head~1(it will delete the 3 commit)
(first commit cant be deleted)(if a commit is deleted the previous commit will be pointer but there is no previous commit for first commit)
(to make not git to track file) create:
   touch .gitignore
   nano .gitignore(put that file name inside the file)


branching
to work isolatedly
create sub branch
then merge with main branch

git branch(to view current branch)
git branch branch_name(create branch)
git checkout branch_name(to switch branches)
git switch branch_name(to switch branch)
git merge branch_name(it will merge to main branch)
git branch -D branch_name(to delete branch)


git remote set-url origin https://token@remainigurl

ci/cd
if build is successful then test will automatically trigger .
if test is successful then deployment will automatically trigger .
if build failed ,it will send a feedback through email to the developer.




Jenkins
how to install Jenkins
 - create a ec2 instance(with .ppk key file)
 -allow needed inbound permission
 - then copy the public ip address
 - go to putty
 - paste the ip address
 - in the side options go to ssh
 - in ssh (click the + symbol) then click on crendentials
 - browse the key file and choose the file
 - give ok
 - it will lead cli
 - it will ask for login name - give the os name( like ubuntu)
 -next create a file .sh file
 - put the script to install Jenkins
 - next in the browser put the public ip address of the instance with :8080 (13.61.33.181:8080)
 - next it will give initialadminpassword
 -copy the url
 -paste it in the cli (with sudo cat url)
 - it will generate password paste the password in the Jenkins
 - next create user
 - that's all




 



plugin-mediator for Jenkins and the software tool
node-end device



in git repo settings
webhook option available
it will notice the the push moment in the git repo
it will notify t=any webhook we add


next session
28/8/25
devops is a practice ,that deploy the application without any manual involvement
 -ci/cd
 -infrastructure automation
 -maintainance and support


creating jobs in jenkins

The build step is where your source code is compiled, packaged, and made ready for testing or deployment.
Build = make the code executable/deployable files
Test = Verify code quality and correctness before deployment.
Unit Tests
  Integration Tests
  End-to-End Tests
  Static Code Analysis / Security Scans


to create a server
-storage
 -processor
 -memory


web server= nginx

to deploy manually
clear
   23  apt install nginx -y
   24  clear
   25  cd /var/www/html/     => default root folder for Nginx web pages.
   26  ls
   27  pwd
   28  ls
   29  rm index.nginx-debian.html
   30  nano index.html
   31  systemctl stop nginx
   32  systemctl start nginx
   33  clear
   34  history



 systemctl status jenkins
    2  apt install nginx -y
    3  cd /var/www/html/
    4  ls
    5  nano index.html
    6  systemctl stop nginx
    7  systemctl start nginx
    8  systemctl stop nginx
    9  systemctl start nginx
   10  ls
   11  nano index.html
   12  systemctl status Jenkins
(to deploy other file)
   13  rm index.html
   14  ls
   15  wget https://freetemplatehub.com/templates/free-salon-website-template/
 


to deploy in aws codepipeline
create one s3 bucket

go to codepipeline



docker(engine) (lite weight component)
lite weight component because it doesn't have any os
we have some problem while deploying using ec2 instance


if we use new server with auto scaling it will need 9 minutes to live

CONTAINERIZATION
the server will come to live within 5 seconds




performance issue
high availability
microservice architecture
environmental issue



Why Containerization is preferred over Virtualization
boot time (to came live)
Virtualization = heavyweight, full OS per app → slower, resource-heavy.

Containerization = lightweight, share host OS → faster, portable, efficient

commands  (container name should be unique)
docker run => used to create container(it will pull and run the container)
docker images =>used to display docker local image repository
docker ps=>used to display the running containers
docker ps -a =>used to display existed containers
docker rmi =>remove image  from local repo
docker stop=> stop the running container
docker start=>stsrt the stopped container
docker restart=> restart the container
docker pull =>used to pull image (if you want to pull the image only )
docker run -it => it will run the
docker run -d -t --name c1 =>  to create contanier
docker exec -it name bash => to enter into the container
docker build .=> convert dockerfile into image



run the container outside vm => bypass
port forwarding


ecr => today topic

create Linux machine
install docker
install codedepoly
set roles to ec2(create roles)
then go to code pipeline(create pipeline)




day -4
to pam.xml => for build
deploy using jenkin
1)create a ec2 instance (ubuntu)
2)install Jenkins in putty
3)create Jenkins
4)install docker in putty
5)




build=>package the application an bundle



cicd (tomcat file)
cant able to deploy the static file
first bundle(convert n no of file into single file)


1)create a ec2 instance (ubuntu)
2)install Jenkins in putty
3)create Jenkins
4)install maven plugin (maven integration plugin) in available plugins
5)select and install
6)after installed successful restart the Jenkins then login again
7)go to manege jenkins=>go to tools=> click on add maven
8)click on build =>go to config
9)build step=>involke toplevel mavens (mavne version M1)
10)advance=>pom=> pom.xml
11)goal =>clean install

deploy{
use pipeline
put groovy script






infrastructure
terraform
create new server
install terraform
install aws cli
login in aws
=>aws configure
go to aws iam
go to user =>security credentials=>create access key
put access key ,secret key and region
next ccreate a s3 bucket
aws s3 ls=>list bucket
command to create bucket in cli=> aws s3 mb s3://bucket-name


create bucket using terraform in cli
mkdir aws
pwd
mkdir  s3
pwd
nano script.tf
terraform init
terraform plan
terraform apply
terraform destroy


next ec2 in terraform
mkdir ec2
nano script.tf
terraform init
terraform apply

ec2 in terraform with user data


anisbile
create two ec2
master and slave
ssh -i demo.pem ubuntu@ip to login
sudo passwd

create password for root user(get permission)
ssh root@ip
cd /etc/ssh/
ls
cd sshd_config-d
ls
60-cloudimg-settinngs.conf
nano 60-cloudimg-settinngs.conf

nano sshd_config-d
change the password area so that root user also can use password
then restart


hostnamectl set-hostname slave-1
exec hostname

adduser name

real

to create integration of ansible and terraform using aws
1=> create two instance
    *master
    *slave
2=>next go to putty

3=>next do slave
go to putty
create a session using slave public ip
convert into root user =>sudo su
commands
hostnamectl set-hostname slave=> create host
adduser aish => add user
sudo vi /etc/ssh/sshd_config => this will go to one file there change 	#PermitRootLogin yes then came out using :wq like Linux (to write use i then only you can made change)
sudo systemctl daemon-reload
sudo systemctl restart ssh
sudo mkdir -p /home/aish/.ssh
sudo nano /home/aish/.ssh/authorized_keys=> put that key that is generated in master
sudo chown -R aish:aish /home/aish/.ssh
sudo chmod 700 /home/aish/.ssh
sudo chmod 600 /home/aish/.ssh/authorized_keys
sudo systemctl restart ssh


4=>next do master
hostnamectl set-hostname Master
sudo apt update
sudo apt install ansible -y
ansible --version
ssh-keygen -t rsa
cat /root/.ssh/id_rsa.pub =>generate a key


ssh aish@publicip of slave


  password aish




in master
mkdir -p /etc/ansible
nano /etc/ansible/hosts
=> inside the file
[webserver]
private ip of the slave  ansible_user=aish (user name) (dont leave space in username)
 
[Database]
comeout of the file
next
ansible all -m ping

to create a foleder
 ansible all -m file -a "path=/home/aish/dir1 state=directory
ansible all -m command -a "ls /home/aish/"  to view(list) what is in the slave machine
to create file ansible all -m  command -a "touch /home/aish/text.txt"
to delte file ansible all -m command -a "rm /home/aish/text.txt"
nano index.html
to compy from master to slave ansible all -m copy -a "src=/home/ubuntu/index.html dest=/home/aish/dir1"
to get permission ansible all -m command -a "chmod 777 /home/aish/dir1/index.html"
to view the content in the file ansible all -m command -a "cat /home/aish/dir1/index.html"





nano /etc/passwd =>to view user details
cd /root/.ssh/ =>it give keys created in master




to update
ansible all -m apt -a "update_cache=yes" --become



ansible playbook(syntax is important especially identation)
start with --- and end with too
-name: Install and configure Ngix on Ubutu
hosts: all
become: yes
tasks:
-name: Update apt repository cache
 apt:
    update_cache: yes


nano install-nginx.yml
ansible-playbook install-nginx.yml







ls /var/log/ (logs of application and syatem in Linux)

Prometheus(monitoring tool) 9090
Grafana (dashboard)3000 1860 default dashboard in grafana
node exporter (intermediate between the monitoring tool and and the server or application)
